package de.tu_dresden.inf.lat.abox_repairs.experiments.generation;

import de.tu_dresden.inf.lat.abox_repairs.reasoning.IReasonerFacade;
import de.tu_dresden.inf.lat.abox_repairs.reasoning.SimpleReasonerFacade;
import de.tu_dresden.inf.lat.abox_repairs.repair_request.RepairRequest;
import org.semanticweb.owlapi.model.*;
import org.semanticweb.owlapi.model.parameters.Imports;

import java.util.*;
import java.util.stream.Collectors;

public class ComplexRepairRequestGenerator {

    private final Random random;
    private final OWLOntology ontology;
    private final List<OWLNamedIndividual> individuals;
    private final IQGenerator iqGenerator;

    public ComplexRepairRequestGenerator(OWLOntology ontology){
        this(ontology, new Random());
    }

    public ComplexRepairRequestGenerator(OWLOntology ontology, Random random){
        this.random=random;
        this.ontology=ontology;
        this.individuals = new ArrayList(ontology.getIndividualsInSignature());
        this.iqGenerator = new IQGenerator(ontology, random);
    }

    /**
     * access internal iq generator to adapt parameters
     */
    public IQGenerator getIqGenerator(){
        return this.iqGenerator;
    }

    /**
     * Create a random repair request that assigns to the given proportion of individuals a complex EL concept,
     * generated by the interal IQ generator
     * @param proportionIndividuals
     * @return
     */
    public RepairRequest generateRepairRequest(double proportionIndividuals, int conceptsPerIndividual)
            throws IQGenerationException, OWLOntologyCreationException {
        return generateRepairRequest(proportionIndividuals, conceptsPerIndividual, -1);
    }

    /**
     * @param proportionIndividuals how many of the individuals get a repair request assigned
     * @param conceptsPerIndividual how many concepts per individual to we want in the repair request
     * @param maxNumberOfConcepts how many different concepts should occur in the repair request
     * @return
     */
    public RepairRequest generateRepairRequest(double proportionIndividuals, int conceptsPerIndividual, int maxNumberOfConcepts) throws OWLOntologyCreationException {


        IReasonerFacade reasoner = new SimpleReasonerFacade(ontology);
        OWLDataFactory factory = ontology.getOWLOntologyManager().getOWLDataFactory();

        RepairRequest request = new RepairRequest();

        List<OWLClassExpression> conceptsUsed = new ArrayList<>();

        int individualsToSelect = (int)(proportionIndividuals*individuals.size());
        List<OWLNamedIndividual> individuals = new ArrayList<>(ontology.getIndividualsInSignature());

        while(individualsToSelect>0 && !individuals.isEmpty()) {
            int position = random.nextInt(individuals.size());
            OWLNamedIndividual individual = individuals.get(position);
            individuals.remove(position);
            Set<OWLClassExpression> expressions = new HashSet<>();
            try {
                for (int i = 0; i < conceptsPerIndividual; i++) {
                    Optional<OWLClassExpression> expression;
                    if(maxNumberOfConcepts>0 && conceptsUsed.size()>=maxNumberOfConcepts) {
                        expression = pickRandomInstance(individual, conceptsUsed, reasoner);
                    } else {
                         expression = iqGenerator.generateIQ(individual);
                    }
                    if (expression.isPresent() && !reasoner.subsumedBy(factory.getOWLThing(), expression.get())) {
                        expressions.add(expression.get());
                        conceptsUsed.add(expression.get());
                    }
                }
                request.put(individual, expressions);
                individualsToSelect--;
            } catch(IQGenerationException exception) {
                System.out.println("skipped individual "+individuals+" since only owl:Thing implied");
            }
        }

        return request;
    }

    private Optional<OWLClassExpression> pickRandomInstance(OWLNamedIndividual individual, List<OWLClassExpression> expressions, IReasonerFacade reasoner) {
        List<OWLClassExpression> classExpressionsLeft = new ArrayList(expressions);
        while(!classExpressionsLeft.isEmpty()){
            int position = random.nextInt(classExpressionsLeft.size());
            OWLClassExpression next = classExpressionsLeft.get(position);
            classExpressionsLeft.remove(position);
            if(reasoner.instanceOf(individual, next))
                return Optional.of(next);
        }
        return Optional.empty();
    }


    private Set<OWLNamedIndividual> randomIndividuals(OWLOntology ontology, double proportion) {
        Set<OWLNamedIndividual> result = new HashSet<>();

        System.out.println("Requests for "+((int)(proportion*individuals.size()))+" individual names.");

        for(int i=0; i<proportion*individuals.size(); i++) {
            OWLNamedIndividual ind = individuals.get(random.nextInt(individuals.size()));
            while(result.contains(ind)){
                ind = individuals.get(random.nextInt(individuals.size()));
            }
            result.add(ind);
        }
        return result;
    }
}
